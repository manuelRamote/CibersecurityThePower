"use strict";

var Status = {
  SUCCESS_HEADER: -1,
  SUCCESS_EOF: -2,
  ERROR_TIMEOUT: -3,
  ERROR_EXCEPTION: -4
};
var connections = {};
var nextConnectionID = 1;
var encoder = new TextEncoder();
self.addEventListener("message", function _callee(event) {
  var connectionID, _connectionID, _connections$_connect, curOffset, value, reader, intBuffer, byteBuffer, readResponse, errorBytes, written, curLen, _connectionID2, _intBuffer, _byteBuffer, response, headers, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, pair, headerObj, headerText, headerBytes, _written, _errorBytes, _written2;

  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!event.data.close) {
            _context.next = 6;
            break;
          }

          connectionID = event.data.close;
          delete connections[connectionID];
          return _context.abrupt("return");

        case 6:
          if (!event.data.getMore) {
            _context.next = 43;
            break;
          }

          _connectionID = event.data.getMore;
          _connections$_connect = connections[_connectionID], curOffset = _connections$_connect.curOffset, value = _connections$_connect.value, reader = _connections$_connect.reader, intBuffer = _connections$_connect.intBuffer, byteBuffer = _connections$_connect.byteBuffer; // if we still have some in buffer, then just send it back straight away

          if (!(!value || curOffset >= value.length)) {
            _context.next = 33;
            break;
          }

          _context.prev = 10;
          _context.next = 13;
          return regeneratorRuntime.awrap(reader.read());

        case 13:
          readResponse = _context.sent;

          if (!readResponse.done) {
            _context.next = 19;
            break;
          }

          // read everything - clear connection and return
          delete connections[_connectionID];
          Atomics.store(intBuffer, 0, Status.SUCCESS_EOF);
          Atomics.notify(intBuffer, 0); // finished reading successfully
          // return from event handler

          return _context.abrupt("return");

        case 19:
          curOffset = 0;
          connections[_connectionID].value = readResponse.value;
          value = readResponse.value;
          _context.next = 33;
          break;

        case 24:
          _context.prev = 24;
          _context.t0 = _context["catch"](10);
          console.log("Request exception:", _context.t0);
          errorBytes = encoder.encode(_context.t0.message);
          written = errorBytes.length;
          byteBuffer.set(errorBytes);
          intBuffer[1] = written;
          Atomics.store(intBuffer, 0, Status.ERROR_EXCEPTION);
          Atomics.notify(intBuffer, 0);

        case 33:
          // send as much buffer as we can
          curLen = value.length - curOffset;

          if (curLen > byteBuffer.length) {
            curLen = byteBuffer.length;
          }

          byteBuffer.set(value.subarray(curOffset, curOffset + curLen), 0);
          Atomics.store(intBuffer, 0, curLen); // store current length in bytes

          Atomics.notify(intBuffer, 0);
          curOffset += curLen;
          connections[_connectionID].curOffset = curOffset;
          return _context.abrupt("return");

        case 43:
          // start fetch
          _connectionID2 = nextConnectionID;
          nextConnectionID += 1;
          _intBuffer = new Int32Array(event.data.buffer);
          _byteBuffer = new Uint8Array(event.data.buffer, 8);
          _context.prev = 47;
          _context.next = 50;
          return regeneratorRuntime.awrap(fetch(event.data.url, event.data.fetchParams));

        case 50:
          response = _context.sent;
          // return the headers first via textencoder
          headers = [];
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 55;

          for (_iterator = response.headers.entries()[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            pair = _step.value;
            headers.push([pair[0], pair[1]]);
          }

          _context.next = 63;
          break;

        case 59:
          _context.prev = 59;
          _context.t1 = _context["catch"](55);
          _didIteratorError = true;
          _iteratorError = _context.t1;

        case 63:
          _context.prev = 63;
          _context.prev = 64;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 66:
          _context.prev = 66;

          if (!_didIteratorError) {
            _context.next = 69;
            break;
          }

          throw _iteratorError;

        case 69:
          return _context.finish(66);

        case 70:
          return _context.finish(63);

        case 71:
          headerObj = {
            headers: headers,
            status: response.status,
            connectionID: _connectionID2
          };
          headerText = JSON.stringify(headerObj);
          headerBytes = encoder.encode(headerText);
          _written = headerBytes.length;

          _byteBuffer.set(headerBytes);

          _intBuffer[1] = _written; // make a connection

          connections[_connectionID2] = {
            reader: response.body.getReader(),
            intBuffer: _intBuffer,
            byteBuffer: _byteBuffer,
            value: undefined,
            curOffset: 0
          }; // set header ready

          Atomics.store(_intBuffer, 0, Status.SUCCESS_HEADER);
          Atomics.notify(_intBuffer, 0); // all fetching after this goes through a new postmessage call with getMore
          // this allows for parallel requests

          _context.next = 91;
          break;

        case 82:
          _context.prev = 82;
          _context.t2 = _context["catch"](47);
          console.log("Request exception:", _context.t2);
          _errorBytes = encoder.encode(_context.t2.message);
          _written2 = _errorBytes.length;

          _byteBuffer.set(_errorBytes);

          _intBuffer[1] = _written2;
          Atomics.store(_intBuffer, 0, Status.ERROR_EXCEPTION);
          Atomics.notify(_intBuffer, 0);

        case 91:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[10, 24], [47, 82], [55, 59, 63, 71], [64,, 66, 70]]);
});
self.postMessage({
  inited: true
});